IO_CMOS_D_DRIVE					EQU		31E8H
IO_CMOS_P_DRIVE					EQU		3218H
IO_CMOS_SINGLE_DRIVE_MODE		EQU		328CH
IO_CMOS_DRIVE_COUNTER_CHECKSUM	EQU		33CEH

MAX_NUM_DRIVE_ASSIGNMENTS		EQU		'Q'-'D'

DRVMENU_RETUR_TO_MAINMENU		EQU		0
DRVMENU_ITEMNUM_HELP			EQU		1
DRVMENU_SINGLE_DRIVE_MODE		EQU		2
DRVMENU_ITEMNUM_DRIVE_D		EQU		3

BOOTDEVICETYPE_FLOPPYDRIVE		EQU		0
BOOTDEVICETYPE_ROMDRIVE			EQU		5
BOOTDEVICETYPE_HARDDRIVE		EQU		2
BOOTDEVICETYPE_UNASSIGNED		EQU		0FFH



NUM_ASSIGNED_DRIVES		DB	0
SINGLE_DRIVE_MODE		DB	0
DRIVE_ASSIGNMENTS		DB	26 dup (0FFH)	; Drive D to P
						DB	0FFH,0FFH		; Stopper for preventing overflow in counting
DRIVE_COUNTER_CHECKSUM	DB	0

DRVMENU_SELECTION		DB	0
DRVMENU_VALUECHANGED	DB	0


DRVMENU_ITEMS			DB	"BACK TO CMOS MENU",0
						DB	"HELP (PAD0 BUTTON TO SEE HELP)",0
DRVMENU_ITEM_SNGLDRV	DB	"SINGLE DRIVE MODE [OFF]",0
DRVMENU_ITEMS_END:


KEYWORD_DRIVE			DB	"DRIVE",0
						;            0200 SCSI ID=   PART=

DRVMENU_CONFIRM_ITEMS	DB	"SAVE CHANGES",0
						DB	"DISCARD CHANGES",0
						DB	"BACK TO DRIVE-ASSIGNMENT MENU",0

DRVMENU_UNASSIGNED		DB	"*UNASSIGNED*"
DRVMENU_UNASSIGNED_END:

DRVMENU_UNKNOWNDEVICE	DB	"?UNKNOWN DEVICE?"
DRVMENU_UNKNOWNDEVICE_END:

DRVMENU_FLOPPYDRIVE	DB	"FLOPPY DISK DRIVE"
DRVMENU_FLOPPYDRIVE_END:

DRVMENU_SCSIHDD		DB	"SCSI ID=[  ] PART=[  ]"
DRVMENU_SCSIHDD_END:

DRVMENU_ON				DB "[ON ]"
DRVMENU_OFF			DB "[OFF]"

DRVMENU_MISC			DB	0,0,0

DRVMENU_INSTRUCTION1	DB	"USE LEFT & RIGHT TO CHANGE ASSIGNMENT",0
DRVMENU_INSTRUCTION2	DB	"ONLY LAST AND UNASSIGNED DRIVES CAN BE CHANGED",0

DRVMENU_HELP_TEXT		DB	"- CMOS MENU HELP -",0
						DB	"USE GAMEPAD0 UP AND DOWN TO SELECT A DRIVE.",0
						DB	"USE LEFT AND RIGHT TO CHANGE ASSIGNEMENTS.",0
						DB	"DRIVE-LETTER ASSIGNMENT WILL CHANGE:",0
						DB	0
						DB	"UNASSIGNED <-> SCSI ID0 <-> ID1 <-> ID2 <-> ID3 <-> ID4 <-> ID5 <-> ID6 ",0
						DB	0
						DB	"YOU CAN CHANGE ONLY THE LAST DRIVE AND THE UNASSIGNED DRIVE THAT IS",0
						DB	"IMMEDIATELY AFTER THE LAST DRIVE.",0
						DB	0
						DB	"PRESS PAD BUTTON TO GO BACK.",0,0FFH,0FFH



DRVMENU				PROC
						CALL	READ_CMOS_DRIVE_ASSIGNMENTS
						CALL	UPDATE_ASSIGNMENT_MENU

						MOV		BYTE PTR CS:[DRVMENU_SELECTION],0
						MOV		BYTE PTR CS:[DRVMENU_VALUECHANGED],0

DRVMENU_MAINLOOP:
						CALL	MENU_WAIT_PAD_RELEASE

						CALL	CLEAR_FIVE_BELOW

						TEXTLOCATION	INSTRUCTION_X,INSTRUCTION_Y
						MOV		SI,OFFSET DRVMENU_INSTRUCTION1
						CALL	PRINT_TALL

						TEXTLOCATION	INSTRUCTION_X,INSTRUCTION_Y
						MOV		SI,OFFSET DRVMENU_INSTRUCTION2
						CALL	PRINT_TALL

						CALL	COUNT_DRVMENU_CHOICES
						MOVZX	CX,BL
						MOV		SI,OFFSET MENU_EXPAND_BUF
						CALL	DRAWMENU2

						MOV		AX,DISPLACED_DEMOSPLASh_MESSAGE_LOCATION
						CALL	DEMOSPLASH_MESSAGE_MOVABLE

						MOV		AX,DISPLACED_DEMOSPLASh_MESSAGE_LOCATION
						ADD		AL,5
						CALL	HIROSAKI_MESSAGE_MOVABLE

						MOV		AL,CS:[DRIVE_COUNTER_CHECKSUM]
						CALL	ITOX8
						XCHG	AL,AH
						MOV		WORD PTR CS:[DRVMENU_MISC],AX
						TEXTLOCATION	4EH,18H
						MOV		SI,OFFSET DRVMENU_MISC
						CALL	PRINT_TALL

						CALL	COUNT_DRVMENU_CHOICES
						MOVZX	CX,BL
						MOV		AL,CS:[DRVMENU_SELECTION]
						CALL	DRAWARROW

@@:
						CALL	READ_PADA
						CMP		AL,3FH
						JE		@b

						CALL	COUNT_DRVMENU_CHOICES
						MOV		AH,CS:[DRVMENU_SELECTION]
						MOV		CH,BL
						CALL	MOVE_ARROW_BY_PAD
						MOV		CS:[DRVMENU_SELECTION],AH

						CALL	DRVMENU_SKIP_UNCHANGEABLE_DRIVES

						CALL	PAD_TO_LEFT_RIGHT
						JE		SHORT @f
						CALL	DRVMENU_LEFT_RIGHT

@@:
						AND		AL,30H
						CMP		AL,30H
						JE		DRVMENU_MAINLOOP

						MOV		AH,CS:[DRVMENU_SELECTION]

						CMP		AH,DRVMENU_ITEMNUM_HELP
						JNE		SHORT @f
						CALL	DRVMENU_HELP
						JMP		DRVMENU_MAINLOOP

@@:
						CMP		AH,DRVMENU_RETUR_TO_MAINMENU
						JNE		DRVMENU_MAINLOOP

						CMP		BYTE PTR CS:[DRVMENU_VALUECHANGED],0
						JE		SHORT @f

						CALL	DRVMENU_CONFIRM
						CMP		AH,2	; BACK TO DRIVE-LETTER ASSIGNMENT
						JE		DRVMENU_MAINLOOP
						CMP		AH,1	; DISCARD CHANGES
						JE		SHORT @f

						CALL	WRITE_CMOS_DRIVE_ASSIGNMENTS

@@:
						RET


DRVMENU				ENDP



DRVMENU_SKIP_UNCHANGEABLE_DRIVES	PROC

						CALL	COUNT_NUM_ASSIGNED_DRIVES
						CMP		BL,2
						JG		SHORT @f
						RET
@@:
						MOV		AH,CS:[DRVMENU_SELECTION]
						SUB		AH,DRVMENU_ITEMNUM_DRIVE_D
						JNE		SHORT @f

						MOV		AH,BL
						SUB		AH,1
						ADD		AH,DRVMENU_ITEMNUM_DRIVE_D
						MOV		CS:[DRVMENU_SELECTION],AH
						RET

@@:
						SUB		BL,2
						CMP		AH,BL
						JNE		SHORT @f

						MOV		AH,DRVMENU_ITEMNUM_DRIVE_D
						DEC		AH
						MOV		CS:[DRVMENU_SELECTION],AH

@@:
						RET

DRVMENU_SKIP_UNCHANGEABLE_DRIVES	ENDP



; INPUT
;   BX LEFT OR RIGHT  -1,0,OR 1
;	AX PRESERVED
DRVMENU_LEFT_RIGHT		PROC
						PUSH	AX

						MOV		AL,CS:[DRVMENU_SELECTION]
						CMP		AL,DRVMENU_SINGLE_DRIVE_MODE
						JNE		SHORT @f

						; TOGGLE SINGLE-DRIVE MODE
						MOV		AL,CS:[SINGLE_DRIVE_MODE]
						CALL	TOGGLE_1_0
						MOV		DI,OFFSET SINGLE_DRIVE_MODE
						CALL	DRVMENU_STORE_VALUE

						CALL	UPDATE_ASSIGNMENT_MENU
						JMP		SHORT DRVMENU_LEFT_RIGHT_RETURN

@@:
						CMP		AL,DRVMENU_ITEMNUM_DRIVE_D
						JB		SHORT DRVMENU_LEFT_RIGHT_RETURN

						SUB		AL,DRVMENU_ITEMNUM_DRIVE_D
						MOVZX	DI,AL
						SHL		DI,1
						ADD		DI,OFFSET DRIVE_ASSIGNMENTS
						CMP		BYTE PTR [DI],BOOTDEVICETYPE_HARDDRIVE
						JE		SHORT @f

						CMP		BX,0	; FLIP TO SCSI ID 0 ONLY WHEN PLUS
						JLE		SHORT DRVMENU_LEFT_RIGHT_RETURN

						MOV		AL,BOOTDEVICETYPE_HARDDRIVE
						CALL	DRVMENU_STORE_VALUE

						XOR		AL,AL
						CALL	DRVMENU_SET_NEXT_PARTITION_NUMBER
						ADD		DI,1
						CALL	DRVMENU_STORE_VALUE

						CALL	UPDATE_ASSIGNMENT_MENU

						JMP		SHORT DRVMENU_LEFT_RIGHT_RETURN


@@:
						; DI POINTS TO THE 2-BYTE OF THE HARD DRIVE ASSIGNMENT
						; [DI] IS CHECKED TO BE BOOTDEVICETYPE_HARDDRIVE

						CMP		BYTE PTR [DI+2],BOOTDEVICETYPE_UNASSIGNED
						JNE		SHORT DRVMENU_LEFT_RIGHT_RETURN	; ONLY THE LAST DRIVE CAN BE EDITED

						MOVZX	CX,BYTE PTR [DI+1]
						SHR		CL,4
						AND		CL,0FH	; CL IS SCSI ID

						ADD		CX,BX
						JNS		SHORT @f

						; SCSI ID BECOME NEGATIVE
						; UNASSIGN DRIVE
						MOV		AL,0FFH
						CALL	DRVMENU_STORE_VALUE
						MOV		AL,0FFH
						ADD		DI,1
						CALL	DRVMENU_STORE_VALUE
						CALL	UPDATE_ASSIGNMENT_MENU

						JMP		SHORT DRVMENU_LEFT_RIGHT_RETURN


@@:
						CMP		CX,6
						JA		SHORT DRVMENU_LEFT_RIGHT_RETURN	; ONLY UP TO 6

						MOV		AL,CL
						SHL		AL,4

						CALL	DRVMENU_SET_NEXT_PARTITION_NUMBER
						ADD		DI,1
						CALL	DRVMENU_STORE_VALUE

						CALL	UPDATE_ASSIGNMENT_MENU


DRVMENU_LEFT_RIGHT_RETURN:
						POP		AX
						RET
DRVMENU_LEFT_RIGHT		ENDP



DRVMENU_DELETE_LAST_DRIVE	PROC
						MOV		DI,OFFSET DRIVE_ASSIGNMENTS
						CMP		BYTE PTR [DI],0FFH
						JNE		SHORT @f
						RET

@@:
						CMP		BYTE PTR [DI+2],0FFH
						JE		SHORT @f
						ADD		DI,2
						JMP		@b

@@:
						MOV		AL,0FFH
						CALL	DRVMENU_STORE_VALUE
						ADD		DI,1
						MOV		AL,0FFH
						CALL	DRVMENU_STORE_VALUE
						CALL	UPDATE_ASSIGNMENT_MENU
						RET
DRVMENU_DELETE_LAST_DRIVE	ENDP



DRVMENU_HELP			PROC
						CALL	MENU_WAIT_PAD_RELEASE

						CALL	CLEAR_FIVE_BELOW

						MOV		AX,0105H
						MOV		SI,OFFSET DRVMENU_HELP_TEXT
						CALL	DRAW_TEXT

@@:
						CALL	READ_PADA
						CMP		AL,3FH
						JE		@b


						RET
DRVMENU_HELP			ENDP


; INPUT
;   AL HIGH 4-BIT    SCSI ID
; OUTPUT
;   AL LOW 4-BIT    PARTITION NUMBER
;   AH NOT PRESERVED
DRVMENU_SET_NEXT_PARTITION_NUMBER	PROC
						PUSH	SI
						PUSH	CX
						PUSH	BX

						MOV		AH,AL
						AND		AH,0F0H		; AH=SCSI ID
						XOR		AL,AL

						MOV		SI,OFFSET DRIVE_ASSIGNMENTS
						MOV		CX,MAX_NUM_DRIVE_ASSIGNMENTS

DRVMENU_SET_NEXT_PARTITION_OUTER_LOOP:
						MOV		BH,[SI]

						CMP		BH,BOOTDEVICETYPE_UNASSIGNED
						JE		DRVMENU_SET_NEXT_PARTITION_BREAK
						CMP		BH,BOOTDEVICETYPE_HARDDRIVE
						JNE		DRVMENU_SET_NEXT_PARTITION_CONTINUE

						MOV		BH,[SI+1]

						AND		BH,0F0H		; BH=SCSI ID
						CMP		AH,BH
						JNE		DRVMENU_SET_NEXT_PARTITION_CONTINUE

						MOV		BH,[SI+1]
						AND		BH,0FH		; BH=PARTITION NUMBER
						INC		BH
						CMP		AL,BH
						JGE		DRVMENU_SET_NEXT_PARTITION_CONTINUE

						MOV		AL,BH

DRVMENU_SET_NEXT_PARTITION_CONTINUE:
						ADD		SI,2
						LOOP	DRVMENU_SET_NEXT_PARTITION_OUTER_LOOP

DRVMENU_SET_NEXT_PARTITION_BREAK:
						AND		AL,0FH
						OR		AL,AH

						POP		BX
						POP		CX
						POP		SI
						RET
DRVMENU_SET_NEXT_PARTITION_NUMBER	ENDP



; INPUT
;   DS:DI  DESTINATION
;   AL     VALUE TO WRITE
DRVMENU_STORE_VALUE	PROC
						XCHG	AL,BYTE PTR [DI]
						SUB		AL,BYTE PTR [DI]	; AL=OLDVALUE-NEWVALUE
						ADD		BYTE PTR CS:[DRIVE_COUNTER_CHECKSUM],AL

						; VALUE=OLDVALUE+(NEWVALUE-OLDVALUE)
						; SUM=OLDSUM+(NEWVALUE-OLDVALUE)+(NEWCOUNTERCHECKSUM-OLDCOUNTERCHECKSUM)
						; (NEWVALUE-OLDVALUE)+(NEWCOUNTERCHECKSUM-OLDCOUNTERCHECKSUM)=0
						; NEWCOUNTERCHECKSUM=OLDCOUNTERCHECKSUM+(OLDVALUE-NEWVALUE)

						OR		BYTE PTR CS:[DRVMENU_VALUECHANGED],0FFH

						RET
DRVMENU_STORE_VALUE	ENDP



READ_CMOS_DRIVE_ASSIGNMENTS	PROC
						PUSH	ES

						PUSH	CS
						POP		ES
						MOV		DX,IO_CMOS_D_DRIVE
						MOV		DI,OFFSET DRIVE_ASSIGNMENTS
@@:
						INSB
						ADD		DX,2
						INSB
						ADD		DX,2
						CMP		DX,IO_CMOS_P_DRIVE
						JBE		@b

						MOV		DX,IO_CMOS_SINGLE_DRIVE_MODE
						IN		AL,DX
						MOV		CS:[SINGLE_DRIVE_MODE],AL

						MOV		DX,IO_CMOS_DRIVE_COUNTER_CHECKSUM
						IN		AL,DX
						MOV		CS:[DRIVE_COUNTER_CHECKSUM],AL

						POP		ES
						RET
READ_CMOS_DRIVE_ASSIGNMENTS	ENDP



WRITE_CMOS_DRIVE_ASSIGNMENTS	PROC
						PUSH	ES

						PUSH	CS
						POP		ES
						MOV		DX,IO_CMOS_D_DRIVE
						MOV		SI,OFFSET DRIVE_ASSIGNMENTS
@@:
						OUTSB
						ADD		DX,2
						OUTSB
						ADD		DX,2
						CMP		DX,IO_CMOS_P_DRIVE
						JBE		@b

						MOV		AL,CS:[SINGLE_DRIVE_MODE]
						MOV		DX,IO_CMOS_SINGLE_DRIVE_MODE
						OUT		DX,AL

						MOV		AL,CS:[DRIVE_COUNTER_CHECKSUM]
						MOV		DX,IO_CMOS_DRIVE_COUNTER_CHECKSUM
						OUT		DX,AL

						POP		ES
						RET
WRITE_CMOS_DRIVE_ASSIGNMENTS	ENDP



; Output
;   BL  Number of CMOS Menu Choices
COUNT_DRVMENU_CHOICES	PROC
						CALL	COUNT_NUM_ASSIGNED_DRIVES

						CMP		BL,MAX_NUM_DRIVE_ASSIGNMENTS
						JGE		SHORT @F
						INC		BL

@@:
						ADD		BL,DRVMENU_ITEMNUM_DRIVE_D
						RET
COUNT_DRVMENU_CHOICES	ENDP



; Output
;   BL	Number of drives assigned (D drive and later)
COUNT_NUM_ASSIGNED_DRIVES	PROC
						PUSH	SI

						MOV		BL,0
						MOV		SI,OFFSET DRIVE_ASSIGNMENTS
@@:
						CMP		BYTE PTR CS:[SI],0FFH
						JE		SHORT @f
						ADD		SI,2
						INC		BL
						JMP		@b
@@:
						POP		SI
						RET
COUNT_NUM_ASSIGNED_DRIVES	ENDP



UPDATE_ASSIGNMENT_MENU		PROC
						PUSH	ES

						PUSH	CS
						POP		ES

						MOV		SI,OFFSET DRVMENU_OFF

						MOV		DI,OFFSET DRVMENU_ITEM_SNGLDRV+18
						CMP		BYTE PTR CS:[SINGLE_DRIVE_MODE],0
						JE		SHORT @f
						MOV		SI,OFFSET DRVMENU_ON

@@:
						MOV		CX,5
						REP		MOVSB


						MOV		CX,DRVMENU_ITEMS_END-DRVMENU_ITEMS
						MOV		SI,OFFSET DRVMENU_ITEMS
						MOV		DI,OFFSET MENU_EXPAND_BUF
						REP		MOVSB



						MOV		CX,MAX_NUM_DRIVE_ASSIGNMENTS
						MOV		AH,'D'
						MOV		SI,OFFSET DRIVE_ASSIGNMENTS

UPDATE_ASSIGNMENT_MENU_OUTER_LOOP:
						PUSH	AX
						PUSH	CX
						PUSH	SI
						PUSH	DI

						MOV		SI,OFFSET KEYWORD_DRIVE
						MOV		CX,5
						REP		MOVSB
						MOV		AL,' '
						STOSW
						STOSB	; Make "DRIVE D "

						POP		DI
						POP		SI
						PUSH	SI
						PUSH	DI


						MOV		AL,[SI]
						CALL	ITOX8
						XCHG	AL,AH
						MOV		[DI+8],AX

						MOV		AL,[SI+1]
						CALL	ITOX8
						XCHG	AL,AH
						MOV		[DI+10],AX

						MOV		WORD PTR [DI+12],0020h ; ' ',00
						ADD		DI,13

						MOV		AX,[SI]
						CMP		AL,BOOTDEVICETYPE_UNASSIGNED
						JNE		SHORT @f

						MOV		SI,OFFSET DRVMENU_UNASSIGNED
						MOV		CX,(OFFSET DRVMENU_UNASSIGNED_END)-(OFFSET DRVMENU_UNASSIGNED)
						REP		MOVSB
						JMP		SHORT UPDATE_ASSIGNMENT_MENU_NEXT
@@:
						CMP		AL,BOOTDEVICETYPE_FLOPPYDRIVE
						JNE		SHORT @F

						MOV		SI,OFFSET DRVMENU_FLOPPYDRIVE
						MOV		CX,(OFFSET DRVMENU_FLOPPYDRIVE_END)-(OFFSET DRVMENU_FLOPPYDRIVE)
						REP		MOVSB
						JMP		SHORT UPDATE_ASSIGNMENT_MENU_NEXT
@@:
						CMP		AL,BOOTDEVICETYPE_HARDDRIVE
						JE		SHORT @F

						MOV		SI,OFFSET DRVMENU_UNKNOWNDEVICE
						MOV		CX,(OFFSET DRVMENU_UNKNOWNDEVICE_END)-(OFFSET DRVMENU_UNKNOWNDEVICE)
						REP		MOVSB
						JMP		SHORT UPDATE_ASSIGNMENT_MENU_NEXT

@@:
						PUSH	DI
						MOV		SI,OFFSET DRVMENU_SCSIHDD
						MOV		CX,(OFFSET DRVMENU_SCSIHDD_END)-(OFFSET DRVMENU_SCSIHDD)
						REP		MOVSB
						POP		DI

						SUB		DI,13

						; TRANSLATE AH (SCSIID|PARTITION)
						XCHG	AL,AH
						PUSH	AX
						AND		AL,0FH
						CALL	ITOX8
						XCHG	AL,AH
						MOV		[DI+32],AX

						POP		AX
						SHR		AL,4
						AND		AL,0FH
						CALL	ITOX8
						XCHG	AL,AH
						MOV		[DI+22],AX

						ADD		DI,(OFFSET DRVMENU_SCSIHDD_END)-(OFFSET DRVMENU_SCSIHDD)+13

UPDATE_ASSIGNMENT_MENU_NEXT:
						MOV		AL,0
						STOSB

						POP		DI
						POP		SI
						POP		CX
						POP		AX
						XCHG	DI,SI
						CALL	SKIP_CSTR_DS_SI
						XCHG	DI,SI
						INC		AH
						ADD		SI,2
						DEC		CX
						JNE		UPDATE_ASSIGNMENT_MENU_OUTER_LOOP

						POP		ES
						RET
UPDATE_ASSIGNMENT_MENU		ENDP



; OUTPUT
;   AH CHOICE
DRVMENU_CONFIRM		PROC

						CALL	MENU_WAIT_PAD_RELEASE
						CALL	CLEAR_FIVE_BELOW

						MOV		CX,3
						MOV		SI,OFFSET DRVMENU_CONFIRM_ITEMS
						CALL	DRAWMENU2

						MOV		AH,2

DRVMENU_CONFIRM_MAINLOOP:
						; AH=SELECTION
						PUSH	AX

						MOV		CX,3
						MOV		AL,AH
						CALL	DRAWARROW

						CALL	MENU_WAIT_PAD_RELEASE

						POP		AX

@@:
						CALL	READ_PADA
						CMP		AL,3FH
						JE		@b

						MOV		CH,3
						CALL	MOVE_ARROW_BY_PAD
@@:
						AND		AL,30H
						CMP		AL,30H
						JE		DRVMENU_CONFIRM_MAINLOOP

						PUSH	AX
						CALL	MENU_WAIT_PAD_RELEASE
						POP		AX

						; AH is still the selection

						RET
DRVMENU_CONFIRM		ENDP
