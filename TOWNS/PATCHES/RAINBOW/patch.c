#include <stdio.h>
#include <stdlib.h>



const int popBack=1;  // Delete last N bytes.
const char append[]=
{
0x56,0xC6,0x05,0x67,0x7A,0x00,0x00,0xC3,0xBE,0xCF,0x79,0x00,0x00,0xE8,0x3C,0x00,  // 00
0x00,0x00,0xBE,0x88,0x79,0x00,0x00,0xE8,0x32,0x00,0x00,0x00,0xBE,0x0B,0x7A,0x00,  // 01
0x00,0xC7,0x06,0x66,0xB8,0xC0,0x55,0xC7,0x46,0x04,0x66,0x33,0xC9,0xCD,0x66,0xC7,  // 02
0x46,0x08,0x93,0xC3,0xBE,0x39,0x7A,0x00,0x00,0xC7,0x06,0x66,0xB8,0xC0,0x56,0xC7,  // 03
0x46,0x04,0x66,0x33,0xC9,0xCD,0x66,0xC7,0x46,0x08,0x93,0xC3,0x5E,0xC3,0xC7,0x06,  // 04
0x66,0xB8,0xC0,0x52,0xC7,0x46,0x04,0x66,0x33,0xC9,0xCD,0xC7,0x46,0x08,0x93,0x66,  // 05
0xB8,0xC0,0xC7,0x46,0x0C,0x72,0x66,0x8B,0x1E,0xC7,0x46,0x10,0x66,0x8B,0x4E,0x02,  // 06
0xC7,0x46,0x14,0x66,0x8B,0x56,0x04,0xC7,0x46,0x18,0xCD,0x93,0xC3,0x90,0xC3,0x90,  // 07
0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,  // 08
0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,  // 09
0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,  // 0A
0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,  // 0B
0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,  // 0C
0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,  // 0D
0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,  // 0E
0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,  // 0F
0xC3
};


const char patchExpandBackFrom[]=
{
//;000C:000A78D4 BE367A0A00               MOV	ESI,000A7A36
//;000C:000A78D9 B954010000               MOV	ECX,00000154
//;000C:000A78DE F2A4                     REPNE MOVSB 
//;000C:000A78E0 47                       INC	EDI
//;000C:000A78E1 FFE7                     JMP	EDI
0xBE,0x36,0x7A,0x0A,0x00,
0xB9,0x54,0x01,0x00,0x00,
0xF2,0xA4,
0x47,
0xFF,0xE7
};

const char patchExpandBackTo[]=
{
0xBE,0x36,0x7B,0x0A,0x00,
0xB9,0x54,0x02,0x00,0x00,
0xF2,0xA4,
0x47,
0xFF,0xE7
};



int ApplyPatch(
    int nByte,unsigned char byteData[],
    int nPatchFrom,const unsigned char patchFrom[],
    int nPatchTo,const unsigned char patchTo[])
{
	int nOccurrence=0;
	for(int i=0; i<nByte; ++i)
	{
		int found=1;
		for(int j=0; j<nPatchFrom && i+j<nByte; ++j)
		{
			if(byteData[i+j]!=patchFrom[j])
			{
				found=0;
				break;
			}
		}
		if(0!=found)
		{
			printf("Apply Patch at %08x\n",i);
			for(int j=0; j<nPatchTo; ++j)
			{
				byteData[i+j]=patchTo[j];
			}
			++nOccurrence;
		}
	}
	return nOccurrence;
}

unsigned int ReadInt(const unsigned char *ptr)
{
	return  ((unsigned int)ptr[3]<<24) |
	        ((unsigned int)ptr[2]<<16) |
	        ((unsigned int)ptr[1]<< 8) |
	        ((unsigned int)ptr[0]    );
}

void WriteInt(unsigned char *ptr,unsigned int value)
{
	ptr[0]=( value     &255);
	ptr[1]=((value>> 8)&255);
	ptr[2]=((value>>16)&255);
	ptr[3]=((value>>24)&255);
}

int main(int ac,char *av[])
{
	if(3!=ac)
	{
		fprintf(stderr,"Usage: Patch source-file-name destination-file-name\n");
		return 1;
	}


	int nByte=0,nByteRead=0,nByteWrite=0,nByteWritten=0;
	unsigned char *byteData=NULL;
	FILE *fp;

	fp=fopen(av[1],"rb");
	if(NULL==fp)
	{
		fprintf(stderr,"Cannot Open Input File!\n");
		return 1;
	}

	fseek(fp,0,SEEK_END);
	nByte=ftell(fp);
	fseek(fp,0,SEEK_SET);

	byteData=(unsigned char *)malloc(nByte+sizeof(append));
	if(NULL==byteData)
	{
		fprintf(stderr,"Not Enough Memory Space!\n");
		return 1;
	}
	nByteRead=fread(byteData,1,nByte,fp);
	fclose(fp);

	if(nByteRead!=nByte)
	{
		fprintf(stderr,"File Read Error!\n");
		return 1;
	}

	nByteWrite=nByteRead+sizeof(append)-popBack;

	if(('P'!=byteData[0] || '3'!=byteData[1]) && nByteWrite!=nByteRead)
	{
		fprintf(stderr,"No resizing in non-P3 executable.\n");
		return 1;
	}

	{
		// Thanks Nabe for free386 documentations!
		//+2A d	load image size
		unsigned int binSize;

		binSize=ReadInt(byteData+0x2A);
		printf("Current Load Image Size at 0x2A=%08x\n",binSize);

		binSize+=sizeof(append);
		binSize-=popBack;
		WriteInt(byteData+0x2A,binSize);

		printf("New Load Image Size at 0x2A=%08x\n",binSize);



		//+74 d	load image size
		binSize=ReadInt(byteData+0x74);
		printf("Current Load Image Size at 0x74=%08x\n",binSize);

		binSize+=sizeof(append);
		binSize-=popBack;
		WriteInt(byteData+0x74,binSize);

		printf("New Load Image Size at 0x74=%08x\n",binSize);
	}


	for(int i=0; i<sizeof(append); ++i)
	{
		byteData[nByteRead-popBack+i]=append[i];
	}

	if(0==ApplyPatch(nByte,byteData,sizeof(patchExpandBackFrom),patchExpandBackFrom,sizeof(patchExpandBackTo),patchExpandBackTo))
	{
		fprintf(stderr,"Source Pattern ExpandBack Not Found!\n");
		return 1;
	}



	fp=fopen(av[2],"wb");;
	if(NULL==fp)
	{
		fprintf(stderr,"Cannot Open Input File!\n");
		return 1;
	}

	nByteWritten=fwrite(byteData,1,nByteWrite,fp);
	if(nByteWritten!=nByteWrite)
	{
		fprintf(stderr,"File Write Error!\n");
		return 1;
	}
	fclose(fp);

	printf("Patched!\n");
	return 0;
}
